待解决问题：分片问题中的hash_tag、虚拟槽

### 1、在项目中缓存是如何使用的？

​		考察点：你的项目中是如何使用缓存的？ 为什么要使用缓存？ 不用缓存行不行？用了缓存之后可能会导致什么问题？

​		解答：1.在之前的项目中做了一个注册登录的模块，在实现用户身份校验的时候，我们会把单向加密后的密文存进redis，同时存进浏览器的session中，之后每次请求都会经过过滤器这时会进redis取出密文进行比对；还有之前做游戏后台排行榜的时候使用了Redis的ZSet来做的，因为ZSet的特点就是有序不重复，且分数可以相同；2.那么之前的功能为什么要用Redis呢？主要是基于高性能、高并发的考量，对于一些频繁操作或者mysql耗时且长时间不会变的数据都可以考虑用redis替代，内存的读写速度更快，且单机支撑并发量轻松10w+；3.缓存常见的问题有**缓存与数据库双写不一致**、**缓存雪崩**、**缓存穿透**、**缓存击穿**、**缓存并发竞争**等问题

### 2、Redis的雪崩、穿透和击穿，如何应对？

​		考察点：什么是Redis的雪崩、穿透和击穿？发生这些情况之后会怎么样？系统如何应对这种情况？

#### **缓存雪崩**

​		缓存雪崩：缓存中数据大批量达到过期时间或者缓存机器以外宕机，此时查询数据库压力过大，导致数据库宕机，重启之后，又会被新的流量给打死。

​		应对方法：

- 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
- 事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据

![redis-caching-avalanche-solution](https://doocs.github.io/advanced-java/docs/high-concurrency/images/redis-caching-avalanche-solution.png)

#### **缓存穿透**

​		缓存穿透：是指缓存和数据库中并不存在的数据，却被不断发起请求进行查询，导致数据库压力过大。

​		应对方法：每次数据库只要没有查到值，就写一个空值到缓存，然后设置一个过期时间，这样的话就利用了缓存。

#### **缓存击穿**

​		缓存击穿：是指缓存中没有但数据库中有的数据，某些key并发访问非常大，当无法在缓存中查到的时候，大量的请求就击穿了缓存，同时集中式高并发的访问数据库，这时数据库的压力就会很大。

​		应对方法：

- 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
- 若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

### 3、如何保证缓存与数据库双写一致性？

​		考察点：使用了缓存就可能会出现缓存与数据库存储双写，双写就会有数据一致性问题，若严格要求数据一致性，则读请求和写请求串行化，串到一个内存队列中去，这样可以保证数据一致性，但系统吞吐量会大幅度降低，需要部署更多的机器去支撑线上的一个请求

​		答：最经典的缓存+数据库读写的模式是Cache Aside Pattern。即：

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。（为什么是删除缓存，不是更新缓存？）

​        问题1：先更新数据库，再删除缓存，此时删除缓存失败，即数据库中是新数据，缓存中是旧数据，导致数据不一致

​		解决思路：先删除缓存，再更新数据库。若数据库更新失败，再次查询缓存为空，去读数据库中的旧数据，然后更新到缓存，不存在不一致

​		问题2：数据发生变更，此时先删除了缓存，在更新数据库之前，一个请求过来，去读缓存，而此时缓存为空，则去查询数据库，查到旧数据并将其放入缓存，随后数据变更更新了数据库的值，此时缓存跟数据库的值不一致

​		解决思路：更新数据时，根据数据的唯一标识，将操作路由之后，发送到一个jvm队列。当读取数据时，若数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个jvm内部队列中。

​		优化点：一个队列中，其实**多个更新缓存请求串在一起是没意义的**，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可

​		高并发的场景下可能会导致的问题：

- 读请求长时阻塞
- 读请求并发量过高
- 多服务实例部署的请求路由
- 热点商品的路由问题，导致请求的倾斜

### 4、如何解决Redis的并发竞争问题？（参考其他解决方法）

​		考察点：Redis的并发竞争问题是什么？如何解决这个问题？了解Redis事务的CAS方案吗？

​		答：并发竞争问题：多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了；或者多客户端同时获取一个key，修改值之后再写回去，顺序一错，数据也就错了

​		解决方法：可以基于zookeeper实现分布式锁，每个系统通过zk获取分布式锁，确保同一时间只能有一个系统实例在操作某个key，别人都不允许读和写。

​		你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。

​		每次要**写之前，先判断**一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据

### 5、Redis都有哪些数据类型以及适用场景？

​		考察点：主要是看你有没有全面的了解过redis，有哪些数据类型，适用于什么场景，实际项目里的具体使用等？

​		解决方法：主要数据类型如下

#### String

​		可以做普通的KV操作

#### Hash

​		类似java中的Map，一般可以将结构化的数据，比如一个对象（前提是这个对象没有嵌套其他的队形）给缓存在redis，每次读写缓存，可以操作相应的字段

#### List

​		有序列表，可以通过List存储一些列表型的数据结构，比如粉丝列表、文章评论列表等

​		还可以通过lrange命令，读取某个闭区间内的元素，基于List实现分页查询

​		还可以实现简单的消息队列

#### Set

​		无序集合，自动去重

​		可以进行一些交集、并集、差集的操作，比如共同好友等

#### ZSet

​		有序集合，自动去重，写进去的时候给一个分数，自动根据分数排序

​		可以做排行榜等

### 其他数据类型

​		bitmap

### 6、Redis和Memcached有什么区别？

​		考察点：Redis和Memcached有什么区别？Redis的线程模型是什么？为什么Redis单线程却能支持高并发？

#### Redis和Memcached的区别

​		应答：相对于Memcached来说，Redis支持复杂的数据结构，并且还支持集群模式（Redis3.x），即cluster模式，而Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；就性能而言，Redis只使用单核，而Memcached可以使用多核，100k数据是一个分界线。

#### Redis的线程模型

​		Redis 内部使用文件事件处理器 `file event handler` ，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 socket
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

​        多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。

来看客户端与 Redis 的一次通信过程：

![Redis-single-thread-model](https://doocs.github.io/advanced-java/docs/high-concurrency/images/redis-single-thread-model.png)

​		要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。

​		首先，Redis 服务端进程初始化的时候，会将 server socket 的 `AE_READABLE` 事件与连接应答处理器关联。

​		客户端 socket01 向 Redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 `AE_READABLE` 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给**连接应答处理器**。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 `AE_READABLE` 事件与命令请求处理器关联。

​		假设此时客户端发送了一个 `set key value` 请求，此时 Redis 中的 socket01 会产生 `AE_READABLE` 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 `AE_READABLE` 事件，由于前面 socket01 的 `AE_READABLE` 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 `key value` 并在自己内存中完成 `key value` 的设置。操作完成后，它会将 socket01 的 `AE_WRITABLE` 事件与命令回复处理器关联。

​		如果此时客户端准备好接收返回结果了，那么 Redis 中的 socket01 会产生一个 `AE_WRITABLE` 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 `ok` ，之后解除 socket01 的 `AE_WRITABLE` 事件与命令回复处理器的关联。这样便完成了一次通信

#### 为什么Redis单线程性能也能这么高？

- 纯内存操作。
- 核心是基于非阻塞的 IO 多路复用机制。
- C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
- 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

### 7、Redis的过期策略有哪些？

### 8、Redis事务？

### 9、Redis的高可用如何部署？

### 10、Redis6.0的多线程特性？