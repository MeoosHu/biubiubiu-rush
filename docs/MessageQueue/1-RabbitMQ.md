### 1.RabbitMQ的应用场景

​		异步处理、应用解耦、流量削峰

​		**项目中的场景*

### 2.幂等性保障

幂等性：对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的

- 幂等常见场景：

  在付款时，由于网络原因导致系统提示支付失败，于是又付了一次，若此时发现扣了两次款....

- 常用思路：

  1. MVCC

     多版本并发控制，乐观锁的一种实现，在数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功。例如博客点赞次数自动+1的接口：

     ```
     public boolean addCount(Long id, Long version);
     ```

     ```
     update blogTable set count= count+1,version=version+1 where id=321 and version=123 
     ```

     每一个version只有一次执行成功的机会，一旦失败必须重新获取。

  2. 去重表

     利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求再也无法成功写入。

     例子还是上述的博客点赞问题，要想防止一个人重复点赞，可以设计一张表，将博客id与用户id绑定建立唯一索引，每当用户点赞时就往表中写入一条数据，这样重复点赞的数据就无法写入。

  3. Token机制

     这种机制就比较重要了，适用范围较广，有多种不同的实现方式。其核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。

     以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。

     每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。

### 3.死信队列

死信队列：DLX，Dead-Letter-Exchange。当消息在一个队列中变成死信（dead message）之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。

消息变成死信有以下几种情况：

- 消息被拒绝（basic.reject/basic.nack），并且requeue=false
- 消息TTL过期
- 队列达到最大长度

> TTL：Time to Live，即一条消息或者该队列中的所有消息的最大存活时间

特点：

- DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性
- 当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列
- 可以监听这个队列中消息作相应的处理，这个特性可以弥补RabbitMQ3.0以前支持的immediate参数的功能

设置：

- 首先需要设置死信队列的exchange和queue，然后进行绑定：
  1. Exchange:dlx.rxchange
  2. Queue:dlx.queue
  3. RoutingKey:#
- 然后我们进行正常声明交换机、队列、绑定，只不过我们需要在队列加上一个参数即可：arguments.put("x-dead-letter-exchange","dlx.exchange")
- 这样消息在过期、requeue、队列在达到最大长度时，消息就可以直接路由到死信队列

### 4.延时队列

**延时队列**：用来存放需要在指定时间被处理的元素的队列

TTL：即一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用

https://www.cnblogs.com/mfrank/p/11260355.html

