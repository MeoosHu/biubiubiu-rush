# 工厂模式

## **应用场景**

创建逻辑比较复杂，考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用分离，比如：

1. 类似规则配置解析，代码中存在大量if-else，动态根据不同类型创建不同对象，可将if-else抽离出来放至工厂类；若创建逻辑比较简单，推荐简单工厂模式
2. 单个对象本身的创建过程比较复杂，例如要组合其他类的对象，做各种初始化工作；当创建逻辑比较复杂，推荐工厂方法

## **简单工厂**

就是根据不同类型创建不同的对象，将其封装为一个工厂类，负责创建对象；也可将创建的对象缓存到map中，可以节省内存和对象创建的时间，算是单例和简单工厂的结合

## **工厂方法**

在简单工厂的基础上，利用多态的特性面向接口编程，即每个实现类负责一种对象的创建，更加符合开闭原则

## **抽象工厂**

即让一个工厂负责多种不同类型对象的创建，例如颜色、大小属性

**要不要使用工厂模式的标准**

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
- 代码复用：创建代码抽离到独立的工厂类之后可以复用
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

**工厂模式和DI容器有何区别？**

DI容器底层的设计思想就是基于工厂模式，其实就是一个大的工厂类，在程序启动时，根据配置创建好对象，使用时直接从容器中获得即可

DI容器的复杂性更高，负责的是整个应用中对象的创建，同时还负责配置的解析，对象生命周期的管理等

**DI容器的核心功能**

- 配置解析

  容器通过读取配置文件，根据配置文件提供的信息来创建对象

- 对象创建

  所有类的对象都放到了一个工厂类，通过反射机制，可以在程序运行中，动态的加载类、创建类

- 对象生命周期管理

  简单工厂有两种创建方式，一种是每次返回新的对象，另一种时每次都返回事先创建好的对象；如在Spring中，可配置scope属性，若为prototype则返回新创建的对象，若为singleton则返回单例对象

  配置懒加载同上，属性lazy-init表示是否需要懒加载

  对象的init-method和destroy-method还能在对象创建好和销毁前进行对象的初始化和清理工作

## **如何实现一个简单的DI容器（案例待解决-----反射）**

核心逻辑包括两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象

1. 最小原型设计
2. 提供执行入口
3. 配置文件解析
4. 核心工厂类设计   