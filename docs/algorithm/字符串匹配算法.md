**如何借助哈希算法实现高效字符串匹配？**

**BF 算法**

BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。

时间复杂度很高，是 O(n*m)，但实际生产中非常常用，因为一般主串和模式串都不会太长，其次这个算法思想、实现都很简单，符合KISS原则。大部分情况下就够用

**RK 算法**

全称叫 Rabin-Karp 算法，其实就是BF 算法的升级版，即对每个子串分别求哈希值，然后用子串的哈希值和模式串的哈希值比较，缩减了比较的时间开销。理想条件下，RK算法的时间复杂度是O(n)。

RK算法的时间复杂度依赖于哈希算法的设计，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。

**如何实现文本编辑器中的查找功能？**

**BM算法**

它的性能是著名的[KMP 算法](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法)的 3 到 4 倍

**核心思想**

在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。

**算法原理分析**

1. **坏字符规则**

   我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作**坏字符**（主串中的字符）。BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)

2. **好后缀规则**

**BM 算法代码实现**

待补充

**BM 算法的性能分析及优化**

待补充

**如何借助BM算法轻松理解KMP算法？**

**KMP算法**

KMP 算法的时间复杂度是 O(n+m)

**基本原理**

**失效函数计算方法**

**KMP 算法复杂度分析**

KMP 算法的时间复杂度就是 O(m+n)