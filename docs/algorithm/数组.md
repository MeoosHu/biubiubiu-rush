**为什么数组要从 0 开始编号，而不是从 1 开始呢？**

```
a[k]_address = base_address + k * type_size
```

”下标”最确切的定义应该是“偏移（offset）”，即可用来计算内存地址；假若用1编号，则a[k]_address = base_address + （k-1）* type_size，多了一次减法运算，CPU需要多做一次操作

**如何实现随机访问？**

> 数组（Array）是一种**线性表**数据结构。它用一组**连续**的内存空间，来存储一组具有**相同类型**的数据。

特点：

- **线性表**：每个线性表上的数据最多只有前和后两个方向，例如数组、链表、队列、栈等，与之相对应的则是非线性表（二叉树、堆、图等）
- **连续的内存空间和相同类型的数据**：因此数组支持**随机访问**，**根据下标随机访问**的时间复杂度为 O(1)，并不是查询的时间复杂度为O(1)

**低效的插入和删除**

最好情况在末尾，故最好时间复杂度为 O(1)；若数据在开头，则所有数据则都需后移一位，为O(n)

平均时间复杂度为（1+2+3+...+n）/n，即O(n)

**优化**：

1. 插入时，可以将某一位置的元素移至末尾，再添加元素到指定位置（快排），这样复杂度就变为了O(1)
2. 删除时，可以将多个位置的元素先**标记**，最终进行一次删除操作（JVM 标记清除垃圾回收算法）

**容器能否完全替代数组？**

在Java中，ArrayList 最大的优势就是**可以将很多对数组操作的细节封装起来**，并且还**支持动态扩容**

代码规范：扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。

数组的使用场景：

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组

**问题：**

1. JVM的标记清除垃圾回收算法核心理念
2. 二维数组的内存寻址公式