**为什么数组要从 0 开始编号，而不是从 1 开始呢？**

```
a[k]_address = base_address + k * type_size
```

”下标”最确切的定义应该是“偏移（offset）”，即可用来计算内存地址；假若用1编号，则a[k]_address = base_address + （k-1）* type_size，**多了一次减法运算，CPU需要多做一次操作**。

**如何实现随机访问？**

> 数组（Array）是一种**线性表**数据结构。它用一组**连续**的内存空间，来存储一组具有**相同类型**的数据。

特点：

- **线性表**：每个线性表上的数据最多只有前和后两个方向，例如数组、链表、队列、栈等，与之相对应的则是非线性表（二叉树、堆、图等）。
- **连续的内存空间和相同类型的数据**：因此数组支持**随机访问**，**根据下标**随机访问的时间复杂度为 O(1)，并不是查询的时间复杂度为O(1)。误区：查找时间复杂度并不是O(1)，即使是已排序的数组，用二分查找，时间复杂度也是O(logn)。

**低效的插入和删除**

最好情况在末尾，故最好时间复杂度为 O(1)；若数据在开头，则所有数据则都需后移一位，为O(n)；平均时间复杂度为（1+2+3+...+n）/n，即O(n)。

优化：

1. 在数组只是被当成一个存储数据的集合时，进行**插入**时，可以将某一位置的元素移至末尾，再添加元素到指定位置，这样复杂度就变为了O(1)；
2. 在不追求数组的连续性时，**删除**元素时，可以将多个位置的元素先**标记**，最终进行一次删除操作。--->>>JVM 标记清除垃圾回收算法的核心思想

**警惕数组的访问越界问题**

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;//即当i=3时，arr[3]即为变量i的地址，即i=0，导致无限循环，同类型才会出现
        printf("hello world\n");
    }
    return 0;
}
```

分析：函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长，即栈底地址大。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则这段代码仍是未决行为。

**容器能否完全替代数组？**

在Java中，ArrayList 最大的优势就是**可以将很多对数组操作的细节封装起来**，并且还**支持动态扩容**

代码规范：扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，**如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小**。

数组的使用场景：

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组
