问题：Word文档中的单词拼写检查功能是如何实现的？

**散列思想**

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据

**散列函数**

1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2，那 hash(key1) == hash(key2)；
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。（几乎不可能）

**散列冲突**

1. 开放寻址法

   开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？

   - 线性探测：每次探测的步长是 1
   - 二次探测：探测的步长就变成了原来的“二次方”
   - 双重散列：使用一组散列函数直到找到空闲位置

   不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用**装载因子**（load factor）来表示空位的多少

   ```
   散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
   ```

   装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

2. 链表法

   插入的时间复杂度是 O(1)，查找或删除操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。

结论：散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。

**如何设计散列函数？**

- 散列函数不能太复杂，消耗计算时间
- 散列函数生成的值要尽可能随机并且均匀分布
- 在实际应用中，还需要考虑关键字长度、特点、分布、散列表大小等

**装载因子过大了怎么办？**

动态扩容，插入一个数据，最好时间复杂度是 O(1)，最坏情况下时间复杂度是 O(n)，均摊情况下，时间复杂度接近最好情况，就是 O(1)

在动态散列表中，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动**动态缩容**。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了

**如何避免低效的扩容？**

一次性扩容消耗时间过大，可将扩容操作穿插在插入操作中。即当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。

**如何选择冲突解决方法？**

1. 开发寻址法

   优点：数据都存储在数组中，可以有效利用CPU缓存加快查询速度，而且这样实现的散列表序列化比较简单

   缺点：删除数据比较麻烦，需要特殊标记已经删除的数据；由于数据存储在数组，冲突相对链表代价更高，因此装载因子上限不能太大，更浪费内存

   **当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因**

2. 链表法

   优点：对内存的利用率高，即链表结点可以在需要的时候再创建；对大装载因子的容忍度更高；

   缺点：对于比较小的对象的存储，消耗内存；结点分散，对CPU缓存不友好，对执行效率有一定影响；

   **基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表**。

**工业级散列表举例分析**

1. 初始大小：HashMap 默认的初始大小是 16，默认值可以设置；如果知道数据量代销可以通过修改默认初始大小，减少动态扩容的次数，可以提高性能

2. 装载因子和动态扩容：最大装载因子默认是 0.75，当超过时，就会启动扩容，每次扩容为2倍大小

3. 散列冲突解决方法：HashMap 底层采用链表法来解决冲突；JDK8时引入了红黑树，当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表

4. 散列函数

   ```
   int hash(Object key) {
       int h = key.hashCode()；
       return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
   }
   ```

**什么是一个工业级的散列表？应该具有哪些特性？**

- 支持快速的查询、插入、删除操作
- 内存占用合理，不能浪费过多的内存空间
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

**如何实现这样一个散列表呢？**

- 设计一个合适的散列函数
- 定义装载因子阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决方法

**为什么散列表和链表经常在一起使用？**

- LRU 缓存淘汰算法

  借助散列表，我们可以把 LRU 缓存淘汰算法的时间复杂度降低为 O(1)。实现即是新增了一个特殊的字段 hnext，将结点串在散列表的拉链中

- Redis有序集合

  在有序集合中，每个成员对象有两个重要的属性，**key**（键值）和**score**（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据

  按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。

- Java LinkedHashMap

  LinkedHashMap 也是通过散列表和链表组合在一起实现的，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据

  **LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突**。

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据

散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用