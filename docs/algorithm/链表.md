**如何实现LRU缓存淘汰算法？**

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）

解决方法：

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：

   - 如果此时缓存未满，则将此结点直接插入到链表的头部；
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

   **优化方案**：引入散列表，记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)

**底层存储结构**

链表是由一个个独立的内存块组成的，链表可分为单链表、循环链表、双向链表

1. 单链表：插入和删除的时间复杂度是O(1)，随机访问的时间复杂度为O(n)
2. 循环链表：尾结点指向头结点。优点是当要处理的数据具有环型结构特点时，就特别适合采用循环链表，比如著名的**约瑟夫问题**
3. 双向链表：不仅有后继指针next，还有前驱指针prev。双向链表可以支持 O(1) 时间复杂度的情况下找到**前驱结点**，对插入跟删除比较有利；对于**有序链表**的查找效率也较高一些。Java中的LinkedHashMap就使用了双向链表，利用了**空间换时间**的设计思想

**链表VS数组**

数组的优势在于使用的是连续的存储空间，可以借助CPU的缓存机制，随机访问效率高；缺点是大小固定，若数组过大，可能没有连续的内存空间分配，若数组过小，则可能出现空间不够用，此时进行扩容，原数组的拷贝非常耗时。而链表本身没有大小限制，天然支持动态扩容。

若代码对内存的使用比较苛刻，则建议使用数组，因为链表每个节点需要使用额外的空间存储指针，而且链表频繁的插入、删除会导致频繁的内存申请和释放，容易造成内存碎片，就可能导致频繁的GC。

**写链表代码技巧**

- 理解指针或引用的含义

- 警惕指针丢失和内存泄漏

- 利用哨兵简化实现难度

  针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理

  引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**

- 重点留意边界条件处理

- 举例画图，辅助思考

- 多写多练，没有捷径

  - 单链表反转
  - 链表中环的检测
  - 两个有序的链表合并
  - 删除链表倒数第 n 个结点
  - 求链表的中间结点