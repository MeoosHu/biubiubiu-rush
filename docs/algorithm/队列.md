**队列在线程池等有限资源池中的应用**

CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的

当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？

一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理

基于链表实现的无界队列可能会导致过多的请求排队等待，不适合对响应时间比较敏感的系统；基于数组实现的有界队列，队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能

实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队

**如何理解"队列"？**

**先进者先出**，队列也只支持两个操作，入队enqueue()：放一个数据到队列尾部；出队dequeue()：从队列头部取一个元素

队列也是一种**操作受限的线性表数据结构**

**顺序队列和链式队列**

用数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列**

**循环队列**

队列为空的判断条件是 head == tail，队满时，**(tail+1)%n=head**

**阻塞队列和并发队列**

**阻塞队列**其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回

线程安全的队列我们叫作**并发队列**。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因