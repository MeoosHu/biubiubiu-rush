基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作

**如何实现一个通用的、高性能的排序函数？**

- 如何选择合适的排序算法？

  线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法

  如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

  归并排序并不是原地排序算法，空间复杂度是 O(n);快速排序比较适合来实现排序函数

- 如何优化快速排序？

  如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，**这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理**。

  最理想的分区点是：**被分区点分开的两个分区中，数据的数量差不多**。

  较常用、比较简单的分区算法有三数取中法，随机法

- 举例分析排序函数

  qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在小规模数据面前，**O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长**。对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法。