**二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？**

**树**

```
节点的高度：节点到叶子节点的最长路径（边数）
节点的深度：根节点到这个节点所经历的边的个数
节点的层数：节点的深度+1
树的高度：根节点的高度
```

**二叉树**

二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是**左子节点**和**右子节点**

```
满二叉树：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点
完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
```

二叉树的存储也是分为链式存储和顺序存储；因为该二叉树是一颗完全二叉树，则用数组存储会节省内存，因为链表需要额外的开销，而数组连续存储，且完全二叉树在数组存储中不怎么浪费空间。

**二叉树的遍历**

```
前序遍历：对于树中的任意节点，先打印这个节点，然后再打印它的左子树，最后打印它的右子树
中序遍历：对于树中的任意节点，先打印它的左子树，然后再打印它本身，最后打印它的右子树
后序遍历：对于树中的任意节点，先打印它的左子树，然后再打印它的右子树，最后打印节点本身
```

**实际上，二叉树的前、中、后序遍历就是一个递归的过程**，二叉树遍历的时间复杂度是 O(n)

**二叉查找树**

二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

**既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？**

散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)

1. 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列
2. 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)
3. 笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高
4. 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定
5. 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间

**支持重复数据的二叉查找树**

1. 第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
2. 每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树

**二叉查找树的时间复杂度分析**

当左右子树极度不平衡时，就会退化成链表，所以查找时间复杂度就是O(n)

当二叉查找树是一颗完全二叉树时，**时间复杂度其实都跟树的高度成正比，也就是 O(height)**，即完全二叉树的高度小于等于 log2n

极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，即二叉平衡查找树，平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)

**平衡二叉查找树**

**为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？**

 Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了

**什么是“平衡二叉查找树”？**

二叉树中任意一个节点的**左右子树的高度**相差不能大于 1

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题

**平衡**：只要看起来对称，左右子树高度不要相差太多，这样整棵树的高度就相对低，相应的插入、删除、查找等操作的效率高一些

**如何定义一棵“红黑树”？**

平衡二叉查找树有Splay Tree（伸展树）、Treap（树堆）等，但红黑树更广为人知，其实，红黑树是一种不严格的平衡二叉查找树

1. 根节点是黑色的；
2. 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
3. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
4. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

**为什么说红黑树是“近似平衡”的？**

“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。

红黑树的高度近似 2log2n，实际上红黑树的性能更好

**实现红黑树的基本思想**

主要是通过左旋、右旋将上述3、4点恢复

**插入操作的平衡调整**

**删除操作的平衡调整**

插入操作的平衡调整比较简单，但是删除操作就比较复杂

**递归树**

**递归树与时间复杂度分析**

归并排序递归实现的时间复杂度就是O(nlog⁡n)

**实战一：分析快速排序的时间复杂度**

从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)

**实战二：分析斐波那契数列的时间复杂度**

这个算法的时间复杂度就介于 O(2^n)和 O(2^(n/2) 之间

**实战三：分析全排列的时间复杂度**

全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n∗n!)

**堆**

堆是一种**完全二叉树**，堆排序是一种原地的、时间复杂度为 O(nlog⁡n) 的排序算法。快速排序，平均情况下，它的时间复杂度为 O(nlogn)。尽管这两种排序算法的时间复杂度都是 O(nlog⁡n)，甚至堆排序比快速排序的时间复杂度还要稳定，但是，**在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？**

1. 堆排序数据访问的方式没有快速排序友好。
2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序

**如何理解“堆”？**

- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

**如何实现一个堆？**

先得弄清**堆都支持哪些操作**以及**如何存储一个堆**。

完全二叉树比较适合用数组来存储

- 往堆中插入一个元素---堆化
- 删除堆顶元素

**如何基于堆实现排序？**

堆排序时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。

堆排序的过程：

1. 建堆
2. 排序

**堆的应用场景**

1. 优先级队列：合并有序小文件、高性能定时器
2. 利用堆求TopK
3. 利用堆求中位数