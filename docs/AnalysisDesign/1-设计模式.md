### 1.单例模式

单例模式，顾名思义就是只有一个实例，并且她自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

核心代码：构造方法私有化，private。

**（1）懒汉式**

```
public class LHan{
	private static LHan instance;//懒汉式
	
	private LHan(){}   //私有构造方法
	
	public static LHan getInstance(){
		if(instance==null){
			instance = new LHan();
		}
		return instance;
	}
}
```

懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。

**（2）饿汉式**

```
public class EHan{
	private static EHan instance = new EHan();  //饿汉式
	
	private EHan(){}    //私有化构造方法
	
	public static EHan getInstance(){
		return instance;
	}
}
```

饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。

**（3）双检锁**

```
public class DoubleCheck{
	private static DoubleCheck instance;
	
	private DoubleCheck(){}
	
	public static DoubleCheck getInstance(){
		if(instance==null){
			synchronized(DoubleCheck.class){
				if(instance==null){
					instance = new DoubleCheck;
				}
			}
		}
		return instance;
	}
}
```

双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if 条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。

（4）**静态内部类**

```
public class Singleton{
	private static class SingletonHolder{
		private static final Singleton INSTANCE = new Singleton();
	}
	
	private Singleton(){
	
	}
	
	public static final Singleton getInstance(){
		return SingletonHolder.INSTANCE;
	}
}
```

静态内部类的方式效果类似双检锁，但实现更简单。但这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。

**（5）枚举**

```
public enum Singleton{
	INSTANCE;
	
	public void anyMethod(){
	
	}
}
```

枚举的方式是比较少见的一种实现方式，但是看上面的代码实现，却更简洁清晰。并且她还自动支持序列化机制，绝对防止多次实例化。

### 2.工厂模式

### 3.策略模式

### 4.责任链模式

### 5.工厂模式