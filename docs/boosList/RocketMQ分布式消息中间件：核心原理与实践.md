### 1.RocketMQ综述

#### 什么是消息队列？

消息队列（Message Queue），从广义上讲是一种消息队列服务中间件，提供一套完整的信息生产、传递、消费的软件系统。消息队列所涵盖的功能远不止于队列（Queue），其本质是两个进程传递信息的一种方法。两个进程可以分布在同一台机器上，亦可以分布在不同的机器上。

#### 消息队列的使用场景

削峰填谷、程序间解耦、异步处理、数据的最终一致性

#### 常见消息队列 

RocketMQ、Kafka、Pulsar    **(问题：之间的异同？)**

### 2.RocketMQ的生产者原理和最佳实践

#### 相关概念

**生产者组**：一个逻辑概念，在使用生产者实例的时候需要指定一个组名。一个生产者组可以生产多个Topic的消息

**生产者实例**：一个生产者组部署了多个进程，每个进程都可以称为一个生产者实例。

**Topic**：主题名字，一个Topic由若干Queue组成。

**普通消息**：普通消息也称为并发消息，和传统的队列相比，并发消息没有顺序，但是生产消费都是并行进行的，单机性能可达十万级别的TPS。

**分区有序消息**：与Kafka中的分区类似，把一个Topic消息分为多个分区“保存”和消费，在一个分区内的消息就是传统的队列，遵循FIFO（先进先出）原则。

**全局有序消息**：如果把一个 Topic 的分区数设置为 1，那么该 Topic 中的消息就是单分区，所有消息都遵循FIFO（先进先出）的原则。

**延迟消息**：消息发送后，消费者要在一定时间后，或者指定某个时间点才可以消费。在没有延迟消息时，基本的做法是基于定时计划任务调度，定时发送消息。在 RocketMQ中只需要在发送消息时设置延迟级别即可实现。

**事务消息**：主要涉及分布式事务，即需要保证在多个操作同时成功或者同时失败时，消费者才能消费消息。RocketMQ通过发送Half消息、处理本地事务、提交（Commit）消息或者回滚（Rollback）消息优雅地实现分布式事务。

#### 生产者高可用

1. 客户端保证
   - 重试机制：配置项 retryTimesWhenSendFailed表示同步重试次数，默认为 2次
   - 客户端容错
2. Broker端保证
   - 数据同步方式保证

#### 生产者启动流程

![](..\..\picture\DefaultMQProducer.jpg)

#### 消息发送流程

#### 发送消息最佳实践

#### 生产者最佳实践总结

### 3.RocketMQ的消费流程和最佳实践

#### 消费者概述

集群消费、广播消费

可靠消费

- 重试-死信机制
- Rebalance机制 

#### 消费者启动机制

#### 消费者的Rebalance机制

#### 消费进度保存机制

#### 消费方式

pull、push

#### 消息过滤

#### 消费者最佳实践总结

### 4.RocketMQ架构和部署最佳实践

#### RocketMQ架构

#### 常用的部署拓扑和部署实践

### 5.Namesrv

#### Namesrv概述

#### Namesrv架构

#### RocketMQ的路由原理

### 6.Broker存储机制

#### Broker概述

#### Broker存储机制

#### Broker CommitLog索引机制

#### Broker过期文件删除机制

#### Broker主从同步机制

#### Broker的关机恢复机制

### 7.RocketMQ特性——事务消息与延迟消息机制

#### 事务消息概述

#### 事务消息机制

生产者发送事务消息和执行本地事务、Broker存储事务消息、Broker回查事务消息、Broker提交或回滚事务消息

#### 延迟消息概述

#### 延迟消息机制

### 8.RocketMQ源代码阅读

### 9.RocketMQ企业最佳实践

