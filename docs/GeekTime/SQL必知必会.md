### 基础篇

#### SQL按照功能划分

1. DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。
2. DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。
3. DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。
4. DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。

#### SQL大小写规范

1. 表名、表别名、字段名、字段别名等都小写；
2. SQL 保留字、函数名、绑定变量等都大写。

#### 主流DBMS介绍

- 关系型：Oracle、MySQL、SQL Server、PostgreSQL
- 键值型：Redis，典型的使用场景是作为内容缓存
- 文档型：MongoDB，一个文档就相当于一条记录
- 搜索引擎：Elasticsearch、Splunk 和、Solr，搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”。
- 列式数据库：Cassandra、HBase，可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。
- 图形数据库：利用了图这种数据结构存储了实体（对象）之间的关系。最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。

#### 不同数据库中的SQL执行过程

- Oracle

![](..\..\picture\Oracle的SQL执行过程.png)

1. 语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。

2. 语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。

3. 权限检查：看用户是否具备访问该数据的权限。

4. 共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？

   在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。

   如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。

5. 优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。

6. 执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。

   > 共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。
   >
   > 库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。

- MySQL

  ![](../../picture/MySQL执行过程.jpg)

- profiling

  含义：开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况

  ```
  select @@profiling;       看下profiling 是否开启，profiling=0 代表关闭
  show profile;             获取上一次查询的执行时间
  show profile for query 2; 查询指定的 Query ID
  ```

#### 设计数据表的原则

1. 数据表的个数越少越好
2. 数据表中的字段个数越少越好
3. .数据表中联合主键的字段个数越少越好
4. 使用主键和外键越多越好

#### SELECT语句的执行顺序

*FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT*

举例：

```
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id  # 顺序 1
WHERE height > 1.80 									# 顺序 2
GROUP BY player.team_id 								# 顺序 3
HAVING num > 2 											# 顺序 4
ORDER BY num DESC 										# 顺序 6
LIMIT 2 												# 顺序 7
```

#### 关于COUNT

1. COUNT(xxx)会忽略值为 NULL 的数据行，COUNT(*) 只是统计数据行数，不管某个字段是否为 NULL
2. 一般情况下：COUNT(\*) = COUNT(1) > COUNT(字段)
   所以尽量使用COUNT(*)，当然如果你要统计的是就是某个字段的非空数据行数，那另当别论。毕竟执行效率比较的前提是要结果一样才行。
3. 如果要统计COUNT(\*)，尽量在数据表上建立二级索引，系统会自动采用key_len小的二级索引进行扫描，这样当我们使用SELECT COUNT(*)的时候效率就会提升，有时候提升几倍甚至更高都是有可能的。

#### And的优先级高于Or

```
select * from table where  条件1 AND  条件2 OR 条件3 AND 条件4
等价于
select * from table where   (  条件1 AND  条件2  )  OR   (  条件3 AND 条件4  ) 
```

#### 在 WHERE 及 ORDER BY 涉及到的列上增加索引

在MySQL中，支持两种排序方式：FileSort和Index排序。Index排序的效率更高，
Index排序：索引可以保证数据的有序性，因此不需要再进行排序。
FileSort排序：一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序，效率较低。

1. SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，ORDER BY子句避免使用FileSort排序。
   当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
   一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。
2. 尽量Using Index完成ORDER BY排序。
   如果WHERE和ORDER BY相同列就使用单索引列；如果不同使用联合索引。
3. 无法Using Index时，对FileSort方式进行调优。

#### 子查询

- 关联子查询与非关联子查询

  ```
  SELECT player_name, height FROM player WHERE height = (SELECT max(height) FROM player)    					
  						非关联子查询（只是从子查询获取数据，和外表没有关联）
  
  SELECT player_name, height, team_id FROM player AS a WHERE height > (SELECT avg(height) FROM player AS b WHERE a.team_id = b.team_id)                  
  						关联子查询 （区别在于a.team_id = b.team_id）   
  ```

  

- EXISTS子查询

  **In和exists的对比**？？？？

   SELECT * FROM A WHERE cc IN (SELECT cc FROM B)

   SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)

  A 表小就用 EXISTS，B 表小就用 IN。

- 集合比较子查询

  - IN:判断是否在集合中
  - ANY:需要与比较操作符一起使用，与子查询返回的任何值做比较
  - ALL:需要与比较操作符一起使用，与子查询返回的所有值做比较
  - SOME:实际上是ANY的别名，作用相同，一般常使用ANY

#### 连接、视图、存储过程、游标

#### 隔离级别与常见异常

### 进阶篇

#### 表设计

- 尽量遵循第三范式

  1. 超键：能唯一标识元组的属性集叫做超键。
  2. 候选键：如果超键不包括多余的属性，那么这个超键就是候选键。
  3. 主键：用户可以从候选键中选择一个作为主键。
  4. 外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。
  5. 主属性：包含在任一候选键中的属性称为主属性。
  6. 非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。

  - 1NF 指的是数据库表中的任何属性都是原子性的，不可再分
  - 2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系
  - 3NF 在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键

- 采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率
- 表字段的数据类型选择

#### 查询优化

- 如果数据重复度高，就不需要创建索引。通常在重复度超过 10% 的情况下，可以不创建这个字段的索引
- 要注意索引列的位置对索引使用的影响。比如我们在 WHERE 子句中对索引字段进行了表达式的计算，会造成这个字段的索引失效
- 注意联合索引对索引使用的影响。我们在创建联合索引的时候会对多个字段创建索引，这时索引的顺序就很重要了
- 要注意多个索引对索引使用的影响。索引不是越多越好，因为每个索引都需要存储空间，索引多也就意味着需要更多的存储空间。此外，过多的索引也会导致优化器在进行评估的时候增加了筛选出索引的计算时间，影响评估的效率

#### 查询路径

物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。

1. 单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。
2. 两张表的连接：常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。
3. 多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接收的范围内。

