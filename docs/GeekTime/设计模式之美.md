### 学习设计模式的目的

1. 应对面试
2. 告别烂代码
3. 提高复杂代码、功能、系统的设计和开发能力
4. 有利于读源码、学框架
5. 指导新人，代码质量，考察面试者水平，有利于职业发展

### 如何评价代码质量

1. **可维护性**：在不破坏原有代码设计、不引入新的bug的情况下，能够快速的修改或者添加代码（**持续重构**）
2. **可读性**：是否符合编码规范、命名、注释、模块划分.....（**编程规范**）
3. **可扩展性**：在不修改或少量修改的前提下，通过扩展的方式添加新的功能代码（**设计模式**、**设计原则**）
4. 简洁性：即KISS原则，"Keep it simple,Stupid"
5. 灵活性、可复用性（**面向对象**）、可测试性

### 面向对象

- 什么是面向对象编程

面向对象编程是一种编程范式或编程风格，类似的还有面向过程编程、函数式编程。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石

- 什么是面向对象编程语言

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便的实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言

- 面向对象分析、设计和编程

面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

- UML图

#### 面向对象的四大特性

- 封装

封装特性需要语言提供一定的语法机制来支持，即访问权限控制，如Java中的public、private。

若没有封装，任何代码都可以修改类中的属性，虽然看起来很灵活，但**过度灵活意味着不可控**，影响代码的**可读性、可维护性**。

- 抽象

指的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的，**抽象通常只需提供函数这个功能即可**。

- 继承

最大的好处就是**代码复用**，编程语言同样需要提供一定的语法支持，例如Java中的extends

- 多态

多态是指子类可以替代父类，在实际代码运行过程中，调用子类的方法实现。多态也需要编程语言提供语法支持，即

> 1.父类对象可引用子类对象
>
> 2.支持继承
>
> 3.支持子类可以重写父类中的方法

除了继承+方法重写外，多态还可以通过另外两种方式实现：接口类、duck-typing（动态语言才支持，如python，js）

**多态能提高代码的可扩展性和复用性**。

#### 哪些代码设计看似是面向对象，实际是面向过程

**滥用getter、setter方法**

在设计实现类的时候，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法要安全些，但如果返回的是集合容器，也要防范集合内部数据被修改的危险

**滥用全局变量和全局方法**

常见的全局变量有单例类对象、静态成员变量、常量等，全局方法有静态方法等。

Constants类不要堆在一个类中，尽量将其拆解为功能更加单一的多个类（**职责单一**），或是哪个类用到了某个常量，就把它定义到这个类中，提高类的内聚性和可复用性。

**定义数据和方法分离的类**

MVC三层架构----基于贫血模型的开发模式是彻底的面向过程编程风格，因为数据和操作是分开定义在VO/BOEntity和Controller/Service/Repository

#### 接口和抽象类的区别

**抽象类的特性**

- 抽象类不允许被实例化，只能被继承
- 抽象类可以包含属性跟方法。可以可以有普通方法和抽象方法
- 子类继承抽象类，必须实现抽象类中的所有抽象方法

**接口的特性**

- 接口不能包含属性
- 接口只能声明方法，方法不能包含代码实现
- 类实现接口的时候，必须实现接口内的所有方法

抽象类侧重于代码复用、接口更侧重于解耦。

如若要表示一种is-a的关系，且是为了解决代码复用问题，就用抽象类；若要表示一种has-a关系，为了解决抽象而非代码复用的问题，就使用接口。

#### 基于接口而非实现编程

设计原则：讲接口和实现相分离，封装不稳定的实现，暴露稳定的接口

1. 函数的命名不能暴露任何细节
2. 封装具体的实现细节（如阿里云特殊的上传、下载不应暴露给调用者）
3. 为实现类定义抽象的接口

在做软件开发的时候，一定要有抽象意识，封装意识，接口意识；接口的定义只表明做什么，而不是怎么做；在设计接口的时候，更应该多想一想，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

#### 组合优于继承

继承的问题在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

而我们往往利用组合、接口、委托来解决继承带来的问题。

- is-a：可通过组合和接口的has-a关系来替代
- 多态特性可以利用接口实现
- 代码复用可以通过组合和委托实现

继承改写为组合意味着要做更更细粒度的类的拆分，即定义了更多的类和接口，这样或多或少也会增加代码的复杂程度和维护成本。

**判断是用组合还是继承？**

类之间的继承结构稳定，继承层次浅，继承关系不复杂，适合继承；反之组合；某些设计模式会固定使用继承或者组合，如装饰者模式、策略模式、组合模式等使用了组合。模板模式使用了继承

#### 基于贫血模型的MVC架构

**贫血模型**：类似XxxxBo、XxxxVo、XxxxEntity这样只包含数据，不包含业务逻辑的类，就叫做贫血模型，是一种典型的面向过程编程风格。

**基于充血模型的DDD开发模式**：**充血模型**与贫血模型相反，数据和对应的业务逻辑被封装到同一个类中，满足面向对象的封装特性，是典型的面向对象编程风格。与传统的基于贫血模型的传统架构区别在于Service层，Service层包含Service类和Domain类，Domain是基于充血模型的。

基于贫血模型的传统开发模式受欢迎的原因：

- 业务系统简单
- 充血模型相对而言更加有难度，需要提前做好很多设计
- 思维固化，转型有成本

基于充血模型的DDD开发模式更加适用于业务复杂的系统开发。在这种开发模式下，Service的实现依赖于Domain类，而Service类则负责一些非功能性和与第三方系统交互的工作，如幂等、事务、消息、日志、调用其他系统的RPC接口等。

> 我们平时的开发大部分都是SQL驱动的开发模式，即根据接口需求来编写SQL语句获取数据，再定义Entity、BO、VO，然后模式化的添加Controller层、Service层、Repository层的代码。
>
> 即使对于简单系统并没有什么问题，但也基本不会有人应用领域模型、OOP的概念，也没有什么代码复用的概念，这种方法在遇到复杂系统时只会导致代码越来越混乱，最终导致无法维护。

#### 对接口鉴权做面向对象分析

**分析**：提出MVP（最小可行性产品），逐步迭代

1. 弄清基本概念
2. 最佳实践有哪些？技术调研
3. ....

**设计**：

1. 将功能点按照职责划分进而识别出有哪些类
2. 定义类及其属性和方法（可根据功能点的动词）
3. 定义类与类之间的交互关系：**泛化**、**实现**、聚合、**组合**、关联、**依赖**
4. 将类组装起来并提供执行入口，例如接口鉴权可以提供一个接口类，暴露一组给外部调用者使用的API接口

### 设计原则

#### 单一职责原则

> Single Responsibility Principle，缩写SRP，意为一个类或者模块只负责完成一个职责或者功能。

**如何判定一个类的职责是否单一？**

根据具体业务，例如一个UserInfo类，单从用户角度来看，可能满足单一职责的设计；但若需要支持物流，则需将地址相关信息抽离；若需要支持统一账户，则需要将身份认证相关的信息抽离。

一般可先写一个粗粒度的类，满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候就可以考虑拆分，这就是**持续重构**。下面有几条判断原则可以参考：

- 类中的代码行数、函数或属性过多，影响了代码的可读性和可维护性
- 类依赖的其他类过多，或依赖类的其他类过多，不符合高内聚、低耦合的设计思想
- 私有方法过多，就需考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类调用，提高代码的复用性
- 给类起名字比较难，很难用业务名词概括，或者只能用一些笼统的Manager、Context，这一般说明类的职责定义不够清晰
- 类中大量方法都是集中操作类的某几个属性，这时可以考虑拆分

#### 开闭原则

> Open Closed Principle，缩写OCP，意为软件实体（模块、类、方法等）应该"对扩展开放，对修改关闭"

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）。

1. 开闭原则并不是说完全杜绝，而是以最小的修改代码的代价来完成新功能的开发
2. 同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”

**如何做到“对扩展开放、修改关闭”？**

主要是要具备一定的扩展意识、抽象意识、封装意识；且需思考未来可能的需求变更，如何设计代码结构以便留好扩展点。

很多设计原则、设计思想、设计模式都是为了提高代码扩展性的，常用的有：多态、依赖注入、基于接口而非实现编程、以及大部分的设计模式（装饰、策略、模板、责任链、状态）

#### 里式替换原则

> Liskov Substitution Principle，缩写为LSP。意为子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

多态虽然和里式替换原则有些类似，但是多态只是面向对象编程的一大特性，也是面向对象编程语言的一种语法，是一种代码实现的思路。

里式替换原则的核心是**按照协议来设计**，下列情况就违反了LSP：

1. 子类违背父类声明要实现的功能
2. 子类违背父类对输入、输出、异常的约定
3. 子类违背父类注释中所罗列的任何特殊说明

**窍门：拿父类的单元测试去测试子类的代码**

#### 接口隔离原则

> Interface Segregation Principle，缩写为ISP；意为客户端不应该强迫依赖它不需要的接口。
>
> 客户端：指接口的调用者或使用者

接口在不同的场景中有不同的意义，在这里我们可以将接口理解为：

- **一组API接口集合**

  如果部分接口只被部分调用者使用，就需将这部分接口隔离出来，单独给对应的调用者使用

- **单个API接口或函数**

  如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一，需要拆分为粒度更细的多个接口或函数

- **OOP中的接口概念**

  可以理解成面向对象编程语言的接口语法，接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

**接口隔离原则与单一职责原则的区别：**

单一职责原则针对的是模块、类、接口的设计。而接口隔离原则则更侧重于接口的设计，另一方面思考角度也不同。接口隔离原则提供了一种判断接口实则是否单一的标准：通过调用者如何使用接口来间接的判断。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一

#### 依赖反转原则

