## 学习设计模式的目的

1. 应对面试
2. 告别烂代码
3. 提高复杂代码、功能、系统的设计和开发能力
4. 有利于读源码、学框架
5. 指导新人，代码质量，考察面试者水平，有利于职业发展

## 如何评价代码质量

1. **可维护性**：在不破坏原有代码设计、不引入新的bug的情况下，能够快速的修改或者添加代码（**持续重构**）
2. **可读性**：是否符合编码规范、命名、注释、模块划分.....（**编程规范**）
3. **可扩展性**：在不修改或少量修改的前提下，通过扩展的方式添加新的功能代码（**设计模式**、**设计原则**）
4. 简洁性：即KISS原则，"Keep it simple,Stupid"
5. 灵活性、可复用性（**面向对象**）、可测试性

## 面向对象

- 什么是面向对象编程

面向对象编程是一种编程范式或编程风格，类似的还有面向过程编程、函数式编程。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石

- 什么是面向对象编程语言

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便的实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言

- 面向对象分析、设计和编程

面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

- UML图

### 面向对象的四大特性

- 封装

封装特性需要语言提供一定的语法机制来支持，即访问权限控制，如Java中的public、private。

若没有封装，任何代码都可以修改类中的属性，虽然看起来很灵活，但**过度灵活意味着不可控**，影响代码的**可读性、可维护性**。

- 抽象

指的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的，**抽象通常只需提供函数这个功能即可**。

- 继承

最大的好处就是**代码复用**，编程语言同样需要提供一定的语法支持，例如Java中的extends

- 多态

多态是指子类可以替代父类，在实际代码运行过程中，调用子类的方法实现。多态也需要编程语言提供语法支持，即

> 1.父类对象可引用子类对象
>
> 2.支持继承
>
> 3.支持子类可以重写父类中的方法

除了继承+方法重写外，多态还可以通过另外两种方式实现：接口类、duck-typing（动态语言才支持，如python，js）

**多态能提高代码的可扩展性和复用性**。

### 哪些代码设计看似是面向对象，实际是面向过程

**滥用getter、setter方法**

在设计实现类的时候，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法要安全些，但如果返回的是集合容器，也要防范集合内部数据被修改的危险

**滥用全局变量和全局方法**

常见的全局变量有单例类对象、静态成员变量、常量等，全局方法有静态方法等。

Constants类不要堆在一个类中，尽量将其拆解为功能更加单一的多个类（**职责单一**），或是哪个类用到了某个常量，就把它定义到这个类中，提高类的内聚性和可复用性。

**定义数据和方法分离的类**

MVC三层架构----基于贫血模型的开发模式是彻底的面向过程编程风格，因为数据和操作是分开定义在VO/BOEntity和Controller/Service/Repository

### 接口和抽象类的区别

**抽象类的特性**

- 抽象类不允许被实例化，只能被继承
- 抽象类可以包含属性跟方法。可以可以有普通方法和抽象方法
- 子类继承抽象类，必须实现抽象类中的所有抽象方法

**接口的特性**

- 接口不能包含属性
- 接口只能声明方法，方法不能包含代码实现
- 类实现接口的时候，必须实现接口内的所有方法

抽象类侧重于代码复用、接口更侧重于解耦。

如若要表示一种is-a的关系，且是为了解决代码复用问题，就用抽象类；若要表示一种has-a关系，为了解决抽象而非代码复用的问题，就使用接口。

### 基于接口而非实现编程

设计原则：讲接口和实现相分离，封装不稳定的实现，暴露稳定的接口

1. 函数的命名不能暴露任何细节
2. 封装具体的实现细节（如阿里云特殊的上传、下载不应暴露给调用者）
3. 为实现类定义抽象的接口

在做软件开发的时候，一定要有抽象意识，封装意识，接口意识；接口的定义只表明做什么，而不是怎么做；在设计接口的时候，更应该多想一想，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

### 组合优于继承

继承的问题在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

而我们往往利用组合、接口、委托来解决继承带来的问题。

- is-a：可通过组合和接口的has-a关系来替代
- 多态特性可以利用接口实现
- 代码复用可以通过组合和委托实现

继承改写为组合意味着要做更更细粒度的类的拆分，即定义了更多的类和接口，这样或多或少也会增加代码的复杂程度和维护成本。

**判断是用组合还是继承？**

类之间的继承结构稳定，继承层次浅，继承关系不复杂，适合继承；反之组合；某些设计模式会固定使用继承或者组合，如装饰者模式、策略模式、组合模式等使用了组合。模板模式使用了继承

### 基于贫血模型的MVC架构

**贫血模型**：类似XxxxBo、XxxxVo、XxxxEntity这样只包含数据，不包含业务逻辑的类，就叫做贫血模型，是一种典型的面向过程编程风格。

**基于充血模型的DDD开发模式**：**充血模型**与贫血模型相反，数据和对应的业务逻辑被封装到同一个类中，满足面向对象的封装特性，是典型的面向对象编程风格。与传统的基于贫血模型的传统架构区别在于Service层，Service层包含Service类和Domain类，Domain是基于充血模型的。

基于贫血模型的传统开发模式受欢迎的原因：

- 业务系统简单
- 充血模型相对而言更加有难度，需要提前做好很多设计
- 思维固化，转型有成本

基于充血模型的DDD开发模式更加适用于业务复杂的系统开发。在这种开发模式下，Service的实现依赖于Domain类，而Service类则负责一些非功能性和与第三方系统交互的工作，如幂等、事务、消息、日志、调用其他系统的RPC接口等。

> 我们平时的开发大部分都是SQL驱动的开发模式，即根据接口需求来编写SQL语句获取数据，再定义Entity、BO、VO，然后模式化的添加Controller层、Service层、Repository层的代码。
>
> 即使对于简单系统并没有什么问题，但也基本不会有人应用领域模型、OOP的概念，也没有什么代码复用的概念，这种方法在遇到复杂系统时只会导致代码越来越混乱，最终导致无法维护。

### 对接口鉴权做面向对象分析

**分析**：提出MVP（最小可行性产品），逐步迭代

1. 弄清基本概念
2. 最佳实践有哪些？技术调研
3. ....

**设计**：

1. 将功能点按照职责划分进而识别出有哪些类
2. 定义类及其属性和方法（可根据功能点的动词）
3. 定义类与类之间的交互关系：**泛化**、**实现**、聚合、**组合**、关联、**依赖**
4. 将类组装起来并提供执行入口，例如接口鉴权可以提供一个接口类，暴露一组给外部调用者使用的API接口

## 设计原则

### 单一职责原则

> Single Responsibility Principle，缩写SRP，意为一个类或者模块只负责完成一个职责或者功能。

**如何判定一个类的职责是否单一？**

根据具体业务，例如一个UserInfo类，单从用户角度来看，可能满足单一职责的设计；但若需要支持物流，则需将地址相关信息抽离；若需要支持统一账户，则需要将身份认证相关的信息抽离。

一般可先写一个粗粒度的类，满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候就可以考虑拆分，这就是**持续重构**。下面有几条判断原则可以参考：

- 类中的代码行数、函数或属性过多，影响了代码的可读性和可维护性
- 类依赖的其他类过多，或依赖类的其他类过多，不符合高内聚、低耦合的设计思想
- 私有方法过多，就需考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类调用，提高代码的复用性
- 给类起名字比较难，很难用业务名词概括，或者只能用一些笼统的Manager、Context，这一般说明类的职责定义不够清晰
- 类中大量方法都是集中操作类的某几个属性，这时可以考虑拆分

### 开闭原则

> Open Closed Principle，缩写OCP，意为软件实体（模块、类、方法等）应该"对扩展开放，对修改关闭"

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）。

1. 开闭原则并不是说完全杜绝，而是以最小的修改代码的代价来完成新功能的开发
2. 同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”

**如何做到“对扩展开放、修改关闭”？**

主要是要具备一定的扩展意识、抽象意识、封装意识；且需思考未来可能的需求变更，如何设计代码结构以便留好扩展点。

很多设计原则、设计思想、设计模式都是为了提高代码扩展性的，常用的有：多态、依赖注入、基于接口而非实现编程、以及大部分的设计模式（装饰、策略、模板、责任链、状态）

### 里式替换原则

> Liskov Substitution Principle，缩写为LSP。意为子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

多态虽然和里式替换原则有些类似，但是多态只是面向对象编程的一大特性，也是面向对象编程语言的一种语法，是一种代码实现的思路。

里式替换原则的核心是**按照协议来设计**，下列情况就违反了LSP：

1. 子类违背父类声明要实现的功能
2. 子类违背父类对输入、输出、异常的约定
3. 子类违背父类注释中所罗列的任何特殊说明

**窍门：拿父类的单元测试去测试子类的代码**

### 接口隔离原则

> Interface Segregation Principle，缩写为ISP；意为客户端不应该强迫依赖它不需要的接口。
>
> 客户端：指接口的调用者或使用者

接口在不同的场景中有不同的意义，在这里我们可以将接口理解为：

- **一组API接口集合**

  如果部分接口只被部分调用者使用，就需将这部分接口隔离出来，单独给对应的调用者使用

- **单个API接口或函数**

  如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一，需要拆分为粒度更细的多个接口或函数

- **OOP中的接口概念**

  可以理解成面向对象编程语言的接口语法，接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

**接口隔离原则与单一职责原则的区别：**

单一职责原则针对的是模块、类、接口的设计。而接口隔离原则则更侧重于接口的设计，另一方面思考角度也不同。接口隔离原则提供了一种判断接口实则是否单一的标准：通过调用者如何使用接口来间接的判断。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一

### 依赖反转原则

> Dependency Inversion Principle,缩写为DIP；意为高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

**控制反转（IOC）**

控制反转实际上是一种设计思想，并不是具体的实现，一般用来进行框架设计。“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

**依赖注入（DI）**

是一种具体的编码技巧，即不通过new()的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好以后，通过构造函数、函数参数等方式传递（或注入）给类使用。

**依赖注入框架（DI Framework）**

即通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员做的事情

### KISS原则和YAGNI原则

> **KISS原则**：Keep It Simple and Stupid

**如何写出满足KISS原则的代码？**

1. 不要使用同事可能不懂得技术来实现代码。例如：正则、高级语法等
2. 不要重复造轮子，要善于利用已经有的工具类库
3. 不要过度优化。不要过度使用一些奇技淫巧（比如，使用位运算符替代算数运算、复杂的条件语句替代is-else、使用过于底层的函数）来优化代码，牺牲了代码的可读性

> **YAGNI原则**：You Ain't Gonna Need It.

即不要设计当前用不到的功能，不要编写当前用不到的代码。即不要做过度设计。

### DRY原则

> Don't Repeat Yourself，意为不要写重复的代码。

常见的有三种代码重复的情况：

1. **实际逻辑重复**：实现逻辑重复，但功能语义不同，并不违反 DRY原则
2. **功能语义重复**：实现逻辑不重复，但功能语义重复，违反了DRY原则
3. **代码执行重复**：代码执行重复违反了DRY原则

**如何提高代码复用性？**

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装
- 应用模板等设计模式

> Rule of Three。即第一次不必考虑复用性；第二次遇到复用场景的时候，再进行重构使其能够复用。

### 迪米特法则

> Law of Demeter，意为不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。

**高内聚**：相近的功能应该放到同一个类

**松耦合**：类与类之间的关系简单清晰

"高内聚、松耦合"是一种设计思想，旨在提高代码的可读性和可维护性

**业务系统如何做好需求分析和设计？**

**需求分析**

学会"借鉴"，然后再结合业务实现微创新；再加以线框图、用户用例

**系统设计**

- 合理的将功能划分到不同模块

  一般来说为了避免业务知识的耦合，更应让下层系统更加通用，即单一职责

- 设计模块与模块之间的交互关系

  上下层系统之间的调用倾向于通过同步接口、同层之间的调用倾向于异步消息调用

- 设计模块的接口、数据库、业务模型

**为什么要分MVC三层开发？**

1. 分层能起到代码复用的作用

   同一个Repository、Service可能被多个Service、Controller调用，如若重复实现，则违反了DRY原则

2. 分层能起到隔离变化的作用

   即抽象和封装的设计思想，如Repository封装了对数据库访问的操作，提供抽象的数据访问接口，基于接口而非实现编程。

3. 分层能起到隔离关注点的作用

   Repository层关注数据读写，Service关注业务逻辑，Controller关注数据校验、封装、格式转换等，更加符合单一职责原则，内聚性更好

4. 分层能提高代码的可测试性

   单元测试不依赖不可控的外部组件

5. 分层能应对系统的复杂性

------

**通用框架开发如何做好需求分析和设计？**

**功能性需求分析**

拆解需求，应用线框图挖掘需求

**非功能性需求分析**

- 易用性

  框架是否易集成、易插拔、跟业务代码是否松耦合等

- 性能

  低延迟，即不影响接口响应时间；框架本身对内存消耗不大

- 扩展性

  使用者在不修改框架源码，甚至不拿到框架源码的情况下，为框架开发新的功能

- 容错性

  不能因为框架本身的异常导致接口请求出错

- 通用性

  提高框架的复用性，能够灵活运用到各类场景

**框架设计**

借鉴TDD（测试驱动开发）和Prototype（最小原型）的设计思想，先聚焦于一个小功能的实现，然后迭代开发，逐步优化。

**面向对象设计与实现**

1. 划分职责进而识别出有哪些类
2. 定义类及类与类之间的关系（可以用设计原则来审视设计是否合理）
3. 将类组装起来并提供执行入口

**Review设计和实现**

对于SOLID、KISS、DRY、YAGNI、LOD等设计原则，基于接口而非实现编程、多用组合少用继承、高内聚低耦合等设计思想，可以看看自己的代码是否符合要求

推荐书籍：

- 设计模式：《设计模式》、《Head Frist 设计模式》、《Java与模式》
- 面向对象：《深入浅出面向对象分析与设计》
- 编程规范：《代码大全》、《代码整洁之道》、《编写可读代码的艺术》
- 重构：《重构》、《重构与模式》、《修改代码的艺术》

------



## 规范与重构

### 重构的目的、对象、时机和方法

**重构的目的：为什么要重构？**

保持代码质量处于可控状态，同时，对我们应用设计原则、模式、编程规范等理论知识到实操有很大的帮助

**重构的对象：到底重构什么？**

大型重构：对顶层代码设计的重构，如系统、模块、代码结构、类与类之间的关系等，手段有：分层、模块化、解耦、抽象可复用组件等，需要应用一些设计思想、原则和模式

小型重构：对代码细节的重构，主要对类、函数、变量等代码级别的重构，手段主要是利用编码规范

**重构的时机：什么时候重构？**

持续重构意识

**重构的方法：又该如何重构？**

大规模高层次的重构难度大，需要有组织、有计划的进行；而小型重构你随时可以进行

### 单元测试

**如何保证重构不出错？**

除了需要对各种设计原则、思想、模式熟练掌握外，还需足够了解业务和代码。另外，除开个人因素，最有效可落地执行保证不出错的手段就是单元测试。

**什么是单元测试？**

单元测试由工程师自己编写，用来测试自己写的代码的正确性，往往测试的是类或者函数是否按预期的逻辑执行得到想要的结果。

**为什么要写单元测试？**

1. 单元测试能有效地帮你发现代码中的bug
2. 写单元测试能帮你发现代码设计上的问题，若很难编写单元测试或写起来很吃力，亦或需要单元测试框架的高级特性来完成，就说明代码设计不够合理
3. 单元测试是对集成测试的有力补充
4. 写单元测试的过程本身就是代码重构的过程
5. 阅读单元测试能帮助你快速熟悉代码
6. 单元测试是TDD可落地执行的改进方案；一般我们可以先写代码，然后写单元测试；根据单元测试反馈的问题去重构代码

**如何编写单元测试？**

就是针对代码设计覆盖各种输入、异常、边界条件的测试用例

- 编写单元测试尽管繁琐，但并不耗时
- 我们可以稍微放低对单元测试代码质量的要求
- 覆盖率作为衡量单元测试质量的唯一标准是不合理的
- 单元测试不要依赖被测代码的具体实现逻辑
- 单元测试框架无法测试，多半是因为代码的可测试性不好

### 代码的可测试性

代码的可测试性即针对代码编写单元测试的难易程度。

依赖注入是编写可测试性代码的最有效手段。

常见的Anti-Patterns：

- 代码中包含未决行为逻辑
- 滥用可变全局变量
- 滥用静态方法
- 使用复杂的继承关系
- 高度耦合的代码

### 如何通过封装、抽象、模块化、中间层解耦代码

**解耦的目的**

解耦是为了实现"高内聚，松耦合"，以保证代码不至于复杂到无法控制的地步。

**代码是否需要解耦？**

- 修改代码会不会牵一发而动全身
- 将模块与模块、类与类之间的依赖关系画出来，根据复杂度来决定

**如何给代码解耦？**

1. 封装和抽象

   封装和抽象可以有效的隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口

2. 中间层

   中间层可以简化依赖关系，对于重构也有极大好处。

3. 模块化

4. 其他设计思想和原则

   单一职责原则、基于接口而非实现编程（接口就相当于中间层）、多用组合少用继承、迪米特法则等

### 编码规范

**命名**

- 关键是能够准确达意，作用域比较小的比如临时变量，推荐短的；而对于类名这种作用域比较大的，推荐长的命名方式
- 利用上下文简化命名；即借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名
- 命名要可读，可搜索；不要使用生僻的、不好读的英文单词来命名；且命名要符合项目的统一规范，不要用反直觉的命名
- 命名接口和抽象类；一种是：接口带前缀I，实现类为xxxService；另一种是接口为xxxxService，实现类带Impl；抽象类是可带前缀"Abstract"，也可不带；总之项目中统一即可

**注释**

注释的目的是为了提高代码的可读性。注释的内容一般包括：做什么、为什么、怎么做。对于复杂的类和接口，还可加上"如何用"；类和函数一定要写注释，函数内部尽量少一些，一般都是用好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

**代码风格**

- 函数的代码行数不要超过一屏幕的大小，类的大小限制比较难确定
- 一行代码最好不要超过屏幕宽度，限制也不能太小
- 善用空行分割单元块
- 推荐两格缩进、以及大括号跟上一行语句同一行
- 类中成员中，依赖类按照字母顺序从小到大排列。类中先写成员变量后写函数；成员变量或函数之间，先静态后普通，并按照作用域大小依次排列

**编程技巧**

- 把代码分割成更小的单元块，因为阅读代码的习惯一般是先整体、后细节，所以要有点模块化和抽象思维
- 避免函数参数过多，且针对函数过多的情况，可作下处理：
  - 考虑函数是否职责单一，能否通过拆分为多个函数的方式来减少参数
  - 将函数的参数封装为对象
- 勿用函数参数来控制逻辑
  - 不要再函数中使用布尔类型的标识参数控制内部逻辑，违背了单一职责原则和接口隔离原则
  - 对于"根据参数是否为null"来控制逻辑的情况也应该进行拆分
- 函数设计要职责单一
- 移除过深的嵌套层次，嵌套最好不要超过两层
  - 去掉多余的if或else语句
  - 使用continue、break、return关键字提前退出嵌套
  - 调整执行顺序来减少嵌套，如先判断为空
  - 将部分嵌套逻辑封装成函数调用
- 学会使用解释性变量
  - 常量取代魔法数字
  - 使用解释性变量来解释复杂表达式

### 如何发现代码质量问题

**常规checklist**

- 目录设置是否合理、模块划分是否清晰、代码结构是否满足"高内聚、松耦合"
- 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD等）
- 设计模式是否应用得当？是否有过度设计？
- 代码是否容易扩展？如果要添加新功能，是否容易实现？
- 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
- 代码是否容易测试？单元测试是否全面覆盖各种正常和异常的情况？
- 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

**业务需求checklist**

- 代码是否实现了预期的业务需求？
- 逻辑是否正确？是否处理了各种异常情况？
- 日志打印是否得当？是否方便debug排查问题？
- 接口是否复用？是否支持幂等、事务等？
- 代码是否存在并发问题？是否线程安全？
- 性能是否有优化空间，比如，SQL、算法是否可以优化？
- 是否有安全漏洞，比如输入校验是否全面？

**重构步骤**

1. 提高代码的可读性
2. 提高代码的可测试性
3. 编写完善的单元测试
4. 添加注释

### 程序出错该返回什么

**返回错误码**

如果有异常机制，则很少用到错误码

**返回NULL值**

大多数情况下，NULL表示"不存在"；对于查找函数，数据不存在并非异常情况，而是一种正常行为。

**返回空对象**

返回NULL值有各种弊端，可以应用空对象设计模式。当函数返回字符串或集合类型的时候，用空字符串或空集合替代NULL表示不存在的情况，这样可以不做NULL值判断

**抛出异常对象**

> 受检异常：编译时异常
>
> 非受检异常：运行时异常

对于抛出的异常，一般有以下处理：

1. 直接吞掉
2. 往上抛出
3. 包裹成新的异常抛出

## 设计模式与范式

### 创建型

#### 单例模式

> 单例：一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫做单例设计模式

**为什么要使用单例？**

- 处理资源访问冲突
- 表示全局唯一类，如配置信息类、唯一递增ID生成器

**如何实现一个单例？**

1. 构造函数是否为private权限，避免外部通过new创造实例
2. 考虑对象创建时的线程安全问题
3. 考虑是否支持延迟加载
4. 考虑getInstance()性能是否高（是否加锁）

举例：

**饿汉式**

```

```

若实例占用资源多或初始化耗时长，提前初始化有点浪费资源，最好在用到的时候去初始化

但是若实例占用资源多，则应按照fast-fail的设计原则，这样又是合理的

**懒汉式**

```

```

synchronized保证了线程安全，但并发度太低

**双重检测**

```

```

即保证了延迟加载，又支持高并发

但因为指令重排序，可能会导致IdGenerator对象被new出来，并赋值给instance之后，还未初始化（执行构造函数），就被另一个线程调用了；要解决需给变量加上volatile关键字，禁止指令重排序；如今高版本的Java已经解决了，即将对象new操作和初始化操作设置为原子操作

**静态内部类**

```

```

外部类被加载时，并不会创建IdGenerator对象，只有调用getInstance方法时，实例才会被加载。instance的唯一性，创建过程的线程安全性，都由JVM保证，既做到了延迟加载，又保证了线程安全。

**枚举**

```

```

由枚举本身的特性，保证了实例创建的线程安全性和实例的唯一性。

**单例存在的问题**

1. 单例对OOP特性的支持不友好
2. 单例会隐藏类之间的依赖关系
3. 单例对代码的扩展性不友好
4. 单例对代码的可测试性不友好
5. 单例不支持有参数的构造函数

**单例有什么替代方案**

静态方法可以保证全局唯一，但不能解决上述问题；可能要通过工厂模式、IOC容器来保证。

若单例类后续没有扩展需求，且不依赖外部系统，就不是反模式了，还是很适用的。

**如何理解单例模式中的唯一性？**

单例模式创建的对象是进程唯一的

**如何实现线程唯一的单例**

利用hashmap，键为线程ID，值为对象，这样即不同的线程对应不同的对象，同一个线程对应于同一个对象

```

```

**如何实现集群环境下的单例？**

将这个单例对象序列化并存储到外部共享存储区（如文件），进程在使用时，都需先去文件中取出对象，使用完后再存储到外部共享存储区；

为了保证进程间，即集群环境下只有一个实例，一个进程获取到对象后，需要对对象加锁，避免其他进程再次获取；在使用完后，需要从内存中删除对象，并解锁

**如何实现一个多例模式？**

跟线程实现唯一单例差不多，都是通过一个map来控制对象的个数

#### 工厂模式

**应用场景**

创建逻辑比较复杂，考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用分离，比如：

1. 类似规则配置解析，代码中存在大量if-else，动态根据不同类型创建不同对象，可将if-else抽离出来放至工厂类；若创建逻辑比较简单，推荐简单工厂模式
2. 单个对象本身的创建过程比较复杂，例如要组合其他类的对象，做各种初始化工作；当创建逻辑比较复杂，推荐工厂方法

**简单工厂**

就是根据不同类型创建不同的对象，将其封装为一个工厂类，负责创建对象；也可将创建的对象缓存到map中，可以节省内存和对象创建的时间，算是单例和简单工厂的结合

**工厂方法**

在简单工厂的基础上，利用多态的特性面向接口编程，即每个实现类负责一种对象的创建，更加符合开闭原则

**抽象工厂**

即让一个工厂负责多种不同类型对象的创建，例如颜色、大小属性

**要不要使用工厂模式的标准**

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
- 代码复用：创建代码抽离到独立的工厂类之后可以复用
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

**工厂模式和DI容器有何区别？**

DI容器底层的设计思想就是基于工厂模式，其实就是一个大的工厂类，在程序启动时，根据配置创建好对象，使用时直接从容器中获得即可

DI容器的复杂性更高，负责的是整个应用中对象的创建，同时还负责配置的解析，对象生命周期的管理等

**DI容器的核心功能**

- 配置解析

  容器通过读取配置文件，根据配置文件提供的信息来创建对象

- 对象创建

  所有类的对象都放到了一个工厂类，通过反射机制，可以在程序运行中，动态的加载类、创建类

- 对象生命周期管理

  简单工厂有两种创建方式，一种是每次返回新的对象，另一种时每次都返回事先创建好的对象；如在Spring中，可配置scope属性，若为prototype则返回新创建的对象，若为singleton则返回单例对象

  配置懒加载同上，属性lazy-init表示是否需要懒加载

  对象的init-method和destroy-method还能在对象创建好和销毁前进行对象的初始化和清理工作

**如何实现一个简单的DI容器（案例待解决-----反射）**

核心逻辑包括两个部分：配置文件解析、根据配置文件通过“反射”语法来创建对象

1. 最小原型设计
2. 提供执行入口
3. 配置文件解析
4. 核心工厂类设计     

#### 建造者模式

**为什么需要建造者模式？**

如果一个类中有很多属性，为了避免构造函数参数过长，影响可读性和易用性，可通过构造函数配合set()方法来解决，但若存在以下情况，则需考虑使用建造者模式**（案例待解决）**

1. 若类的必填属性放置构造函数中，强制创建对象的时候就设置
2. 若类的属性之间有一定的依赖关系或约束条件
3. 若希望创建不可变对象

**工厂模式和建造者模式的区别**

工厂模式是用来创建相同类型的不同对象，由给定的参数决定

建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”创建不同的对象

#### 原型模式

> 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫做原型设计模式，简称原型模式。

对象创建成本大，例如对象中的数据需经过复杂计算、需要从RPC、网络、数据库、文件系统等慢IO中读取，即可考虑原型模式

**原型模式的实现方式：深拷贝和浅拷贝**

浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象

深拷贝得到的是一份完完全全独立的对象,实现有两种方式：

1. 递归拷贝对象、对象的引用对象及引用对象的引用对象，直到要拷贝的数据只包含基本数据类型数据，没有引用对象为止**（案例待解决）**
2. 先将对象序列化，然后再反序列化成新的对象

若要拷贝的对象是不可变对象，使用浅拷贝没问题；但对于可变对象，浅拷贝和原始对象会共享部分数据，可能导致数据被修改，此时应该使用深拷贝

### 结构型

#### 代理模式

**代理模式的原理解析**

在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始列并不是我们开发维护的。这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式

**动态代理的原理解析**

静态代理需要针对每个类都创建一个代理类，代码重复且增加了开发和维护成本。我们可以通过动态代理解决，我们不事先为每个原始类编写代理类，而是在运行的时候动态的创建原始类对应的代理类，然后用代理类替换掉原始类

**代理模式的应用场景**

1. 业务系统的非功能性需求开发，比如监控、统计、鉴权、限流、事务、幂等、日志等（Spring AOP切面完成）
2. 代理模式在RPC、缓存中的应用，如RPC框架可简单的看做代理，使用RPC服务时，无需了解细节，跟调用本地函数一样；



#### 桥接模式

> 桥接模式：将抽象和实现解耦，让它们可以独立变化；或一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展

JDBC驱动是桥接模式的经典应用。

#### 装饰器模式

主要解决继承关系过于复杂的问题，通过组合来替代继承，主要的作用是给原始类添加增强功能，JAVA IO是其典型应用场景

**基于继承的设计方案**

使用继承随着增强功能数的增多，会导致组合爆炸，类继承结构变得复杂无比，代码不好扩展也不好维护

**基于装饰器模式的设计方案**

装饰器模式看起来就是使用了组合，但其实它还有两个特殊的地方

1. 装饰器类和原始类继承同样的父类，这样我们可以对原始类"嵌套"多个装饰器类
2. 装饰器类是对功能的增强

#### 适配器模式

> 用来做适配器，将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作

**适配器模式的原理和实现**

适配器模式有两种实现方式：类适配器和对象适配器。

类适配器使用继承关系来实现，对象适配器使用组合关系来实现

**应用场景**

1. 封装有缺陷的接口设计
2. 统一多个类的接口设计
3. 替换依赖的外部系统
4. 兼容老版本接口
5. 匹配不同格式的数据

Slf4j提供了统一的接口定义，还提供了针对不同日志框架的适配器。我们可以统一使用Slf4j提供的接口来编写打印日志的代码，具体使用哪种日志框架可以动态指定（Java的**SPI**技术）；而且还提供了反向适配器，即满足从一种日志框架替换成另一种日志框架，经由两次适配即可。

**代理、桥接、装饰器、适配器的区别**

其实都可以称为Wrapper模式，即通过Wrapper类二次封装原始类，但应用场景不同

- 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是**控制访问**，而非加强功能，区别于装饰器模式
- 桥接模式：桥接模式的目的是将**接口部分和实现部分分离**，从而让它们可以较为容易、也相对独立地加以改变
- 装饰器模式：装饰器模式再不改变原始类接口的情况下，对原始类功能进行**增强**，并且支持多个装饰器的嵌套使用
- 适配器模式：适配器模式是一种事后的**补救**策略。适配器**提供跟原始类不同的接口**，而代理模式、装饰器模式提供的都是跟原始类相同的接口

#### 门面模式

> 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用

在接口设计时，尽量保持接口的复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口

**应用场景**

1. 解决易用性问题
2. 解决性能问题
3. 解决分布式事务问题

#### 组合模式

> 将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑

组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的遍历递归算法来实现。

#### 享元模式

> "享元",即被共享的单元，是为了复用对象，节省内存，前提是享元对象是不可变对象。

若一个系统中存在大量重复对象或者相似对象中的相同字段，就可以提取出来设计成享元，在内存中只保留一份实例，以节省内存。

享元一般通过工厂模式，在工厂类中，通过一个Map或者List来缓存已经创建好的对象，以达到复用的目的

**享元模式与单例、缓存、对象池**

- 单例：保证对象全局唯一
- 享元模式：实现对象复用，节省内存
- 缓存：提供访问效率，并非复用
- 池化技术："复用"指的是重复使用，为了节省时间

**享元在Java Integer、String中的应用**

```
Integer i1 = 56;
Integer i2 = 56;
Integer i3 = 129;
Integer i4 = 129;
System.out.println(i1==i2);    //true   IntegerCache类缓存了-128~127
System.out.println(i3==i4);    //false
```

String跟Integer类似，但不同的是String是在程序的运行期间，根据需要来创建和缓存字符串常量，这块存储区叫字符串常量池。

实际上，享元模式对JVM的垃圾回收机制不太友好，因为享元工厂类一直保持了对对象的引用，从而导致不会被回收。

因此如果对象生命周期很短，也不会被密集使用，利用享元模式反而是过度设计了。

### 行为型

#### 观察者模式

#### 模板模式

#### 策略模式

#### 责任链模式

#### 状态模式

#### 迭代器模式

#### 访问者模式

#### 备忘录模式

#### 命令模式

#### 解释器模式

#### 中介模式