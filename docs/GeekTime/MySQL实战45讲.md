### 基础篇

#### 一条SQL查询语句是如何执行的？

- server层

  1. 连接器

  2. 查询缓存

  3. 分析器

     词法分析+语法分析

  4. 优化器

     表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序

  5. 执行器

     权限检查

- 存储引擎层

#### 一条SQL更新语句是如何执行的？

redo log、binlog

两阶段提交---保证数据的一致

#### 事务隔离：为什么你改了我还看不见？

ACID、MVCC	

#### 索引

索引的数据结构、以及如何利用减少磁盘IO、页分裂（索引维护）

Percona 的 pt-kill

利用覆盖索引减少回表

#### 锁

全局锁：对数据库实例加锁，**全局锁的典型使用场景是，做全库逻辑备份**、FTWRL 命令

表锁：lock tables … read/write、MDL（**如何安全地给小表加字段？**)

行锁：两阶段锁、在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议（如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放）、死锁和死锁检测

怎么解决由这种热点行更新导致的性能问题呢？

#### 事务

### 实践篇