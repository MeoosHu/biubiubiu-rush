并发编程的第一原则就是不要写并发程序，但现在多核处理器随处可见，所以掌握并发是很有必要的。常见的解决并发问题的模型有**管程**、**信号量**，技术背后的理论和模型往往比技术本身更加重要。Java中的并发大部分都集中在并发包中，而并发包只是针对并发问题开发出来的工具而已，站在理论之上，才能一通百通。

而并发编程往往可以归结为三个问题：**分工**、**互斥**、**同步**。

- 分工：如何高效地拆解任务分配给线程

例如Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法，除此之外，一些设计模式如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。

- 同步：线程之间如何协作运行

一个线程执行完了一个任务，如何通知执行后续任务的线程开工，协作一般是和分工相关的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：**当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行**。

- 互斥：保证同一时刻只允许一个线程访问共享资源

分工、同步主要强调的是性能，而当多个线程同时访问一个共享变量的时候，可能会导致"**线程安全**"问题。而线程不安全往往是由于**可见性**、**有序性**、**原子性**没有得到保障，因此Java引入了**内存模型**解决了可见性问题、有序性问题；同时利用互斥解决了原子性问题，实现互斥的核心技术就是**锁**，即synchronized及各种Lock。

锁虽然解决了安全问题，但也带来了性能问题，所以为了提高性能，Java采取了**分场景优化**的策略，如ReadWriteLock等；亦或无锁的数据结构，如各种原子类；还可以不共享变量或只允许读，如Thread Local、final、Copy-on-write模式。

锁除了性能问题，还要注意**死锁**问题。

![并发编程全景图](../../picture/并发编程全景图.webp)

**推荐资料**

《Java并发编程实战》、《Java并发编程的艺术》、《图解Java多线程设计模式》、《操作系统：精髓与设计原理》

http://ifeve.com 、http://www.cs.umd.edu/~pugh/java/memoryModel/
