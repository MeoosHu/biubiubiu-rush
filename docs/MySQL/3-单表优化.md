#### 单表优化

- 分析：不要上来就考虑分库分表，这样会带来逻辑、运维、部署的各种问题；一般来说，以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有问题的；同时MySQL单表的性能仍然可以进行优化，甚至能正常支撑千万级以上的数据量

##### 字段

1. 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
2. VARCHAR的长度只分配真正需要的空间
3. 使用枚举或整数代替字符串类型
4. 尽量使用TIMESTAMP而非DATETIME
5. 单表不要有太多字段，建议在20以内
6. 避免使用NULL字段，很难查询优化且占用额外索引空间
7. 用整型来存IP
8. 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描
9. 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描
10. 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段
11. 字符字段只建前缀索引
12. 字符字段最好不要做主键
13. 不用外键，由程序保证约束
14. 尽量不用UNIQUE，由程序保证约束
15. 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引

##### 查询SQL

1. 可通过开启慢查询日志来找出较慢的SQL
2. 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边
3. sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
4. 不用SELECT *
5. OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
6. 不用函数和触发器，在应用程序实现
7. 避免%xxx式查询
8. 少用JOIN
9. 使用同类型进行比较，比如用'123'和'123'比，123和123比
10. 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
11. 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
12. 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大

##### 引擎

###### MyISAM

- 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
- 不支持事务
- 不支持外键
- 不支持崩溃后的安全恢复
- 在表有读取查询的时候，支持往表中插入新纪录
- 支持BLOB和TEXT的前500个字符索引，支持全文索引
- 支持延迟更新索引，极大提升写入性能
- 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

InnoDB

- 支持行锁，采用MVCC来支持高并发
- 支持事务
- 支持外键
- 支持崩溃后的安全恢复

总结：MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表